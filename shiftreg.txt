module siso_1( 
	input wire clk, 
	input wire reset, 
	input wire x, 
	output q 
	); 
    	wire q0,q1,q2,q3; 
    	d_flip_flop ad0(clk, reset, x, q0); // D input state 
    	d_flip_flop ad1(clk, reset, q0, q1); // D input state 
    	d_flip_flop ad2(clk, reset, q1, q2); // D input state 
    	d_flip_flop ad3(clk, reset, q2, q3); // D input state 
    	assign q=q3; 
endmodule

module d_flip_flop( 
	input wire clk, 
	input wire reset, 
	input wire d, 
	output reg q 
); 
	always @(posedge clk or posedge reset) begin 
    	if (reset)  
        	q <= 1'b0; // Reset state 
    	else  
        	q <= d; // D input state 
	end 
endmodule 

module sipo_b1( 

	input wire clk,     	// Clock input 
	input wire reset,   	// Reset input 
	input wire serial_in,   // Serial input 
	output reg [3:0] parallel_out // Parallel output 
); 
	// Internal signals 
	reg q0; 
	reg q1; 
	reg q2; 
	reg q3; // Individual flip-flop outputs 
	// Flip-flop logic 
	always @(posedge clk or posedge reset) begin 
    	if (reset) begin 
        	q0 <= 1'b0; // Reset state 
        	q1 <= 1'b0; 
        	q2 <= 1'b0; 
        	q3 <= 1'b0; 
    	end 
    	else begin 
        	q0 <= serial_in; // D input state 
        	q1 <= q0; 
        	q2 <= q1; 
        	q3 <= q2; 
    	end 
	end 
	// Assign output 
	always @* begin 
    	parallel_out = {q3, q2, q1, q0}; // Output connected to the individual flip-flop outputs 
	end 
endmodule

module pipo_b1( 

	input wire clk,        	
	input wire reset,     
	input wire [3:0]parallel_in,
	output reg [3:0] parallel_out 
); 
	// Internal signals 
	reg [3:0] reg_data; // Data register 
	// Register logic 
	always @(posedge clk or posedge reset) begin 
    	if (reset) begin 
        	reg_data <= 4'b0000; // Reset state 
    	end 
    	else begin 
        	reg_data <= parallel_in; // Load parallel input on clock edge 
    	end 
	end 
	// Assign parallel output 
	always @* begin 
    	parallel_out = reg_data; // Output parallel input on parallel output 
	end 
endmodule 

module piso_1( 
	input clk, 
	input pi, 
	input [3:0] data, 
	output [3:0] q 
	); 
  wire x1,x2,x3,x4,x5,x6,x7; 
  wire d1,d2,d3; 
  assign d1=((q[0]&pi)|(~pi&data[1])); 
  assign d2=((q[1]&pi)|(~pi&data[2])); 
  assign d3=((q[2]&pi)|(~pi&data[3])); 
  d_ff DFF1(clk,data[0],q[0]); 
  d_ff DFF2(clk,d1,q[1]); 
  d_ff DFF3(clk,d2,q[2]); 
  d_ff DFF4(clk,d3,q[3]); 
endmodule 
module d_ff(input clk,d,output reg q); 
always@(posedge clk) 
begin 
q<=d; 
end 
endmodule
